/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2022 Igor Zinken - https://www.igorski.nl
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#ifndef __MWENGINE__AUDIOENGINE_H_INCLUDED__
#define __MWENGINE__AUDIOENGINE_H_INCLUDED__

#include "audiobuffer.h"
#include "audiochannel.h"
#include "channelgroup.h"
#include "global.h"
#include "processingchain.h"
#include "resizable_audiobuffer.h"
#include <definitions/drivers.h>
#include <thread>

namespace MWEngine {
class AudioEngine
{
    /**
     * this is the API exposed to an external application
     * for interacting with the AudioEngine (it does nothing
     * more than prepare and start / stop / reset the render thread
     */

    /* public API */

    public:

        static void setup( unsigned int bufferSize, unsigned int sampleRate, unsigned int amountOfChannels );
        static void start( Drivers::types audioDriver );
        static void stop();
        static void reset();

        static AudioChannel* getInputChannel();

        /**
          * when bouncing, the writing of buffers into the hardware is omitted
          * for an increase in bouncing speed (otherwise its real time)
          */
        static void setBounceState( bool isBouncing, int maxBuffers, char* outputFile, int rangeStart, int rangeEnd );

        /**
         * Record the output of the sequencer onto storage
         *
         * isRecording {bool} toggles the recording state
         * maxBuffers {int} the total recorded buffer size to store in memory
         *                  before writing the recorded snippet as .WAV file into
         *                  the given output file's directory.
         * outputFile {char*} name of the output WAV file to generate when recording completes
         *                    (when recording state is disabled), this will concatenate all snippets.
         */
        static void setRecordingState( bool isRecording, int maxBuffers, char* outputFile );

        /**
         * record audio from the Androids input channel, this stores only the incoming audio
         * not the remaining audio processed / generated by the engine
         *
         * isRecording {bool} toggles the recording state
         * maxBuffers {int} the total recorded buffer size to store in memory
         *            before writing the recorded contents as .WAV file into
         *            the given output directory.
         * outputFile {char*} name of the folder to write each snippet into
         * skipProcessing {bool} when true, the device input is recorded onto disk dry, when
         *                false, the ProcessingChain of the input channel is applied prior to writing
         */
        static void setRecordingFromDeviceState( bool isRecording, int maxBuffers, char* outputFile, bool skipProcessing );

        static void recordOutputWithInputSync( bool isRecording, int maxBuffers, char* outputFile );

        /**
         * Save the contents of the snippet at given buffer index
         * onto storage. This should be invoked from a thread separate to the
         * audio rendering thread to prevent buffer under runs from happening
         * while writing the buffer during the rendering of audio output
         */
        static void saveRecordedSnippet( int snippetBufferIndex );

        /* engine properties */

        struct RecordingSettings {
            bool recordDeviceInput;     // whether audio coming from the Android device input should be recorded
            bool recordInputWithChain;  // whether device input audio should apply the ProcessingChain of the input channel
            bool inputToDisk;           // record audio coming from the Android device input to a file
            bool outputToDisk;          // record all audio output to a file
            bool correctLatency;        // sync the device input with the internal audio output (correct latency)
            bool bouncing;              // bounce audio (i.e. render in inaudible offline mode without thread lock) to a file
            int bounceRangeStart;       // when bouncing, this defines the starting point of the bounce range
            int bounceRangeEnd;         // when bouncing, this defines the end point of the bounce range
            int latency;                // input latency on recording start
        };
        static RecordingSettings recordingSettings;

        static int samples_per_beat; // the amount of samples necessary for a single beat at the current tempo and sample rate
        static int samples_per_bar;  // the amount of samples for a full bar at the current tempo and sample rate
        static int samples_per_step; // the amount of samples within a single status update subdivision
        static int amount_of_bars;   // the amount of measures in the current sequencer
        static int steps_per_bar;    // the amount of subdivisions in a single measure the engine broadcast a status update for

#ifndef SWIG
        // internal to the engine

        // renders the audio. this should not be called directly (is called
        // by the audio drivers). Use start() instead (triggers driver activity)

        static bool render( int amountOfSamples );
        static void createOutputBuffer();

        static int min_buffer_position;    // the lowest sample offset in the current loop range
        static int max_buffer_position;    // the maximum sample offset in the current loop range
        static int marked_buffer_position; // the buffer position that should launch a notification when playback exceeds this position
        static int min_step_position;      // the lowest step in the current sequence
        static int max_step_position;      // the maximum step in the current sequence (e.g. 15 for single measure using a 16 step sequencer - step starts at 0.)

        /* buffer read/write pointers */

        static int bufferPosition;      // the current sequence position in samples ("playback head" offset)
        static int stepPosition;        // the current sequence bar subdivided position (e.g. 16th note of a bar)

        /* tempo related */

        static float tempo;                     // the tempo of the sequencer
        static float queuedTempo;               // the tempo the sequencer will move to once current render cycle completes
        static int time_sig_beat_amount;        // time signature upper numeral (i.e. the "3" in 3/4)
        static int time_sig_beat_unit;          // time signature lower numeral (i.e. the "4" in 3/4)
        static int queuedTime_sig_beat_amount;  // the time signature beat amount the sequencer moves to on next cycle
        static int queuedTime_sig_beat_unit;    // the time signature beat unit the sequencer moves to on next cycle

        /* output related */

        static float volume; // master volume

        static std::vector<ChannelGroup*> groups;

        static void handleTempoUpdate( float aQueuedTempo, bool broadcastUpdate );
#endif

        static ProcessingChain* masterBus;  // processing chain for the master bus

        static void addChannelGroup( ChannelGroup* group );
        static void removeChannelGroup( ChannelGroup* group );

    private:

        /* render properties */

        static bool loopStarted; // whether the current buffer will exceed the end offset of the loop (read remaining samples from the start)
        static int  loopOffset;   // the offset within the current buffer where we exceed max_buf_pos and start reading from min_buf_pos
        static int  loopAmount;   // amount of samples we must read from the current loop ranges start offset (== min_buffer_position)
        static int  outputChannels;
        static bool isMono;
        static std::vector<AudioChannel*>* channels;
        static ResizableAudioBuffer* inBuffer;
        static float*  outBuffer;

        static std::thread* thread;
        static bool threadOptimized;

#ifdef PREVENT_CPU_FREQUENCY_SCALING

        /* CPU stabilization related */

        static int64_t _firstRenderStartTime;
        static int64_t _renderedSamples;
        static double  _noopsPerTick;

#endif

        /* recording */

#ifdef RECORD_DEVICE_INPUT
        static float* recbufferIn;
        static AudioChannel* inputChannel;
#endif

        /* internal render methods */

        static void initRenderTask( Drivers::types audioDriver );
        static void handleSequencerPositionUpdate( int bufferOffset );
        static bool writeChannelCache            ( AudioChannel* channel, AudioBuffer* channelBuffer, int cacheReadPos );
};
} // E.O namespace MWEngine

#endif
